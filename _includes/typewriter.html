<script>
	/**
	Cool typewriter effect. 
	
	.toshow tracks blocks not yet shown 
	.showing tracks current block being shown
	current character is tracked by a count data attribute

	Here's the flow:
	To start typewriting pass a selector
	Blocks have a next selector

	IDEAS:
	GLOBAL setInterval for letter update function
	only trigers animation frame if we have updates

	per cursor set interval (but they're all probs changing at the same time)

	CSS SELECTORS
	Give relevent elements a "CURSOR" class
	cursor child nodes get styles applied
	// FUCK THIS IS GONNA BE FUCKY
	I LIKE IT THOUGH

	basic idea:
	start typing adds "cursor" class to the given elements
	// HOW DO WE TELL WHEN

	*/

	let typewriterElements = []
	function startTyping(selector, accum) {
		document.querySelectorAll(selector).forEach(el => {
			accum.push({
				el,
				timeout: 0,
				count: 0,
				textLength: parseInt(el.dataset.textLength | "0"),
				startDelay: parseInt(el.dataset.startDelay | "0"),
				letterDelay: parseInt(el.dataset.letterDelay | "0"),
				endDelay: parseInt(el.dataset.endDelay | "0"),
				nextSelector: el.dataset.nextSelector
			})
		});
	}

	function typeWriterTick(timestamp) {
		result = []
		for (let i = 0; i < typewriterElements.length; i++) {
			let vals = typewriterElements[i];
			let { el, timeout, count, textLength, startDelay, letterDelay, endDelay, nextSelector } = vals;
			if (timestamp <= timeout) {
				result.push(vals);
				//console.log("SKIP", timestamp, timeout);
				continue;
			}

			vals.count += 1;
			if (count == 0) {
				console.log("START", timestamp);
				el.classList.add("showing");
				el.firstElementChild.classList.add("cursor");
				el.firstElementChild.classList.add("blink");
				vals.timeout = timestamp + startDelay;
				result.push(vals);
			} else if (count > textLength + 1) {
				console.log("END1", timestamp);
				el.classList.remove("showing");
				el.classList.remove("toshow");
				if (nextSelector) {
					startTyping(nextSelector, result);
				}
			}
			else if (count > textLength) {
				console.log("END2", timestamp);
				// TODO(P1) maybe combine this and bottom)
				// Note last span is an added one just to allow blinking cursor.
				el.lastElementChild.classList.add("cursor");
				el.lastElementChild.classList.add("blink");
				vals.timeout = timestamp + endDelay;
				result.push(vals);
			} else {
				console.log("LETTER", timestamp);
				el.children[count - 1].classList.add("visible");
				el.children[count - 1].classList.remove("cursor");
				el.children[count - 1].classList.remove("blink");
				el.children[count].classList.add("cursor");
				vals.timeout = timestamp + letterDelay;
				result.push(vals);
			}
		}

		// Update results, request next frame.
		typewriterElements = result;
		if (result.length > 0) {
			window.requestAnimationFrame(typeWriterTick);
		}
	}

	function clearBlocks(selector) {
		document.querySelectorAll(selector).forEach(el => {
			el.classList.remove("showing");
			el.classList.add("toshow");
			el.querySelectorAll(":scope .cursor").forEach(el => {
				el.classList.remove("cursor");
				el.classList.remove("blink");
			})
			el.querySelectorAll(":scope .visible").forEach(el => {
				el.classList.remove("visible");
			})
		})
	}

	function initTypeWritier(selector) {
		// Create a span for each letter.
		document.querySelectorAll(selector).forEach(el => {
			let text = el.innerText;
			el.setAttribute("data-text-length", text.length);
			let h = ""
			for (let i = 0; i < text.length; i++) {
				h += `<span>${text.charAt(i)}</span>`
			}
			h += `<span class="endline">.</span>`
			el.innerHTML = h;
		});
	}
</script>
