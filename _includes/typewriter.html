<script>
	/**
	Cool typewriter effect. 
	
	.toshow tracks blocks not yet shown 
	.showing tracks current block being shown
	current character is tracked by a count data attribute

	Here's the flow:
	To start typewriting pass a selector
	Blocks have a next selector
	*/

	let typewriterElements = []
	function startTyping(selector, accum) {
		document.querySelectorAll(selector).forEach(el => {
			accum.push({
				el,
				prevEl: undefined,
				direction: "forward",
				lastUpdate: 0,
				timeout: 0,
				startDelay: parseInt(el.dataset.startDelay | "0"),
				letterDelay: parseInt(el.dataset.letterDelay | "50"),
				endDelay: parseInt(el.dataset.endDelay | "0"),
				nextSelector: el.dataset.nextSelector
			})
		});
	}

	function typeWriterTick(timestamp) {
		result = []
		for (let i = 0; i < typewriterElements.length; i++) {
			// Each represents a cursor object
			let vals = typewriterElements[i];
			let { el, prevEl, direction, lastUpdate, timeout, startDelay, letterDelay, endDelay, nextSelector } = vals;
			if ((timestamp <= lastUpdate + timeout) && lastUpdate !== 0) {
				//console.log(timestamp, lastUpdate, timeout);
				result.push(vals);
				//console.log("SKIP", timestamp, timeout);
				continue;
			}

			/*if(timestamp > 500) {
				return;
			}*/

			let nextNode = el.nextElementSibling;
			vals.lastUpdate = timestamp;

			if (lastUpdate == 0 && nextNode) {
				el.classList.add("cursor");
				el.classList.add("blink");
				el.classList.add("visible");
				vals.prevEl = el;
				vals.el = nextNode;
				vals.timeout = startDelay;
				result.push(vals);
			} else if(!nextNode || nextNode.matches(".visible,.cursor")) {
				if (el.matches(".done")) {
					el.classList.remove("cursor");
					el.classList.remove("blink");
				} else {
					if(prevEl) {
						prevEl.classList.remove("cursor");
						prevEl.classList.remove("blink");
					}
					el.classList.add("cursor");
					el.classList.add("blink");
					el.classList.add("visible");
					el.classList.add("done");
					vals.timeout = endDelay;
					result.push(vals);
				}
			} else {
				// Middle node
				prevEl.classList.remove("cursor");
				prevEl.classList.remove("blink");
				el.classList.add("cursor");
				el.classList.add("visible");
				vals.el = nextNode;
				vals.prevEl = el;
				vals.timeout = letterDelay;
				result.push(vals);
			}
		}

		// Update results, request next frame.
		typewriterElements = result;
		if (result.length > 0) {
			window.requestAnimationFrame(typeWriterTick);
		}
	}

	function clearBlocks(selector) {
		document.querySelectorAll(selector).forEach(el => {
			el.classList.remove("showing");
			el.classList.add("toshow");
			el.querySelectorAll(":scope .cursor").forEach(el => {
				el.classList.remove("cursor");
				el.classList.remove("blink");
			})
			el.querySelectorAll(":scope .visible").forEach(el => {
				el.classList.remove("visible");
			})
		})
	}

	function initTypeWritier(selector) {
		// Create a span for each letter.
		document.querySelectorAll(selector).forEach(el => {
			let text = el.innerText;
			el.setAttribute("data-text-length", text.length);
			let h = ""
			for (let i = 0; i < text.length; i++) {
				h += `<span>${text.charAt(i)}</span>`
			}
			h += `<span class="endline">.</span>`
			el.innerHTML = h;
		});
	}
</script>
